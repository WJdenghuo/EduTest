// Generated by CoffeeScript 1.12.2
(function() {
  var fn, i, len, ref, ref1, toString, type, util,
    slice = [].slice;

  util = {
    isArray: (ref = Array.isArray) != null ? ref : function(obj) {
      return toString.call(obj) === '[object Array]';
    },
    isNumber: function(obj) {
      return toString.call(obj) === '[object Number]' && !isNaN(obj);
    },
    isPlainObject: function(obj) {
      return (obj != null) && (typeof obj === 'object') && (obj.constructor === Object);
    },
    isPrimitive: function(obj) {
      return util.isString(obj) || util.isNumber(obj) || obj === true || obj === false;
    },
    _uniqueId: 0,
    uniqueId: function() {
      return util._uniqueId++;
    },
    capitalize: function(x) {
      if (x != null) {
        return x.charAt(0).toUpperCase() + x.slice(1);
      }
    },
    fix: function(f) {
      return (function(x) {
        return f(function(y) {
          return x(x)(y);
        });
      })(function(x) {
        return f(function(y) {
          return x(x)(y);
        });
      });
    },
    identity: function(x) {
      return x;
    },
    foldLeft: function(value) {
      return function(arr, f) {
        var elem, i, len;
        for (i = 0, len = arr.length; i < len; i++) {
          elem = arr[i];
          value = f(value, elem);
        }
        return value;
      };
    },
    reduceLeft: function(arr, f) {
      return util.foldLeft(arr[0])(arr.slice(1), f);
    },
    extend: function() {
      var dest, i, k, len, src, srcs, v;
      dest = arguments[0], srcs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (i = 0, len = srcs.length; i < len; i++) {
        src = srcs[i];
        for (k in src) {
          v = src[k];
          dest[k] = v;
        }
      }
      return null;
    },
    extendNew: function() {
      var obj, srcs;
      srcs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {};
      util.extend.apply(util, [obj].concat(slice.call(srcs)));
      return obj;
    },
    isEmptyObject: function(obj) {
      var _;
      if (obj == null) {
        return false;
      }
      for (_ in obj) {
        return false;
      }
      return true;
    },
    superClass: function(klass) {
      if (klass.superclass != null) {
        return klass.superclass;
      } else if (klass.__super__ != null) {
        return klass.__super__.constructor;
      }
    },
    deepGet: function(obj, path) {
      var idx;
      path = util.isArray(path) ? path : util.isString(path) ? path.split('.') : [path.toString()];
      idx = 0;
      while ((obj != null) && idx < path.length) {
        obj = obj[path[idx++]];
      }
      return obj != null ? obj : null;
    },
    deepSet: function(obj, path) {
      var idx, name;
      path = util.isArray(path) ? path : util.isString(path) ? path.split('.') : [path.toString()];
      idx = 0;
      while ((idx + 1) < path.length) {
        obj = obj[name = path[idx++]] != null ? obj[name] : obj[name] = {};
      }
      return function(x) {
        return obj[path[idx]] = x;
      };
    },
    deepDelete: function(obj, path) {
      var idx, oldValue;
      path = util.isArray(path) ? path : path.split('.');
      idx = 0;
      while ((idx + 1) < path.length && (obj != null)) {
        obj = obj[path[idx++]];
      }
      if (idx !== path.length - 1) {
        return;
      }
      if (obj == null) {
        return;
      }
      oldValue = obj[path[idx]];
      delete obj[path[idx]];
      return oldValue;
    },
    traverse: function(obj, f, path) {
      var k, subpath, v;
      if (path == null) {
        path = [];
      }
      for (k in obj) {
        v = obj[k];
        subpath = path.concat([k]);
        if ((v != null) && util.isPlainObject(v)) {
          util.traverse(v, f, subpath);
        } else {
          f(subpath, v);
        }
      }
      return obj;
    },
    traverseAll: function(obj, f, path) {
      var k, subpath, v;
      if (path == null) {
        path = [];
      }
      for (k in obj) {
        v = obj[k];
        subpath = path.concat([k]);
        f(subpath, v);
        if ((obj[k] != null) && util.isPlainObject(obj[k])) {
          util.traverseAll(obj[k], f, subpath);
        }
      }
      return obj;
    }
  };

  toString = Object.prototype.toString;

  ref1 = ['Arguments', 'Function', 'String', 'Date', 'RegExp'];
  fn = function(type) {
    return util['is' + type] = function(obj) {
      return toString.call(obj) === ("[object " + type + "]");
    };
  };
  for (i = 0, len = ref1.length; i < len; i++) {
    type = ref1[i];
    fn(type);
  }

  if (typeof /./ !== 'function') {
    util.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  module.exports = util;

}).call(this);
