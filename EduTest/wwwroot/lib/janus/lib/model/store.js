// Generated by CoffeeScript 1.12.2
(function() {
  var Base, Map, MemoryCacheStore, Model, OnPageCacheStore, OneOfStore, Request, Store, Varying, isArray, isFunction, isNumber, ref, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('../util/util'), isFunction = ref.isFunction, isNumber = ref.isNumber, isArray = ref.isArray;

  types = require('../util/types');

  Base = require('../core/base').Base;

  Model = require('../model/model').Model;

  Map = require('../collection/map').Map;

  Varying = require('../core/varying').Varying;

  Request = (function(superClass) {
    extend(Request, superClass);

    function Request(options) {
      this.options = options != null ? options : {};
      Request.__super__.constructor.call(this, types.result.init());
    }

    Request.prototype.type = types.operation.fetch();

    Request.prototype.signature = function() {};

    Request.prototype.invalidates = void 0;

    Request.prototype.expires = void 0;

    return Request;

  })(Varying);

  Store = (function(superClass) {
    extend(Store, superClass);

    function Store(request1) {
      this.request = request1;
      Store.__super__.constructor.call(this);
    }

    Store.prototype.handle = function() {
      var handled;
      handled = this._handle();
      if (!types.handling.unhandled.match(handled)) {
        this.emit('requesting', this.request);
      }
      return handled;
    };

    Store.prototype._handle = function() {};

    return Store;

  })(Base);

  OneOfStore = (function(superClass) {
    extend(OneOfStore, superClass);

    function OneOfStore() {
      var maybeStores, request;
      request = arguments[0], maybeStores = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.maybeStores = isArray(maybeStores[0]) ? maybeStores[0] : maybeStores;
      OneOfStore.__super__.constructor.call(this, request);
    }

    OneOfStore.prototype._handle = function() {
      var handled, i, len, maybeStore, ref1;
      handled = types.handling.unhandled();
      ref1 = this.maybeStores;
      for (i = 0, len = ref1.length; i < len; i++) {
        maybeStore = ref1[i];
        handled = maybeStore.prototype != null ? (new maybeStore(this.request)).handle() : maybeStore.handle();
        if (types.handling.handled.match(handled)) {
          break;
        }
      }
      if (!types.handling.handled.match(handled)) {
        this.request.set(types.result.failure("No handler was available!"));
        return types.handling.unhandled();
      } else {
        return handled;
      }
    };

    return OneOfStore;

  })(Store);

  MemoryCacheStore = (function(superClass) {
    extend(MemoryCacheStore, superClass);

    function MemoryCacheStore() {
      MemoryCacheStore.__super__.constructor.call(this);
      this._cache = new Map();
    }

    MemoryCacheStore.prototype.handle = function(request) {
      var after, base, cache, hit, i, key, len, ref1, signature;
      signature = request.signature();
      if (types.operation.mutate.match(request.type)) {
        ref1 = this._cache.enumerate();
        for (i = 0, len = ref1.length; i < len; i++) {
          key = ref1[i];
          if ((typeof (base = this._cache.get(key)).invalidate === "function" ? base.invalidate(request) : void 0) === true) {
            this._cache.unset(key);
          }
        }
      }
      if (signature != null) {
        if (types.operation.fetch.match(request.type)) {
          hit = this._cache.get(signature);
          if (hit != null) {
            if (request !== hit) {
              request.bind(hit);
            }
            return types.handling.handled();
          } else {
            this._cache.set(signature, request);
            if (request.expires != null) {
              after = isFunction(request.expires) ? request.expires() : request.expires;
              if (isNumber(after)) {
                setTimeout(((function(_this) {
                  return function() {
                    return _this._cache.unset(signature);
                  };
                })(this)), after * 1000);
              }
            }
            return types.handling.unhandled();
          }
        } else if (types.operation.mutate.match(request.type)) {
          this._cache.unset(signature);
          if (request.cacheResult !== false && !types.operation["delete"].match(request.type)) {
            cache = this._cache;
            request.reactLater(function(result) {
              if (types.result.success.match(result)) {
                cache.set(signature, request);
              }
              if (types.result.complete.match(result)) {
                return this.stop();
              }
            });
          }
          return types.handling.unhandled();
        } else {
          this._cache.unset(signature);
          return types.handling.unhandled();
        }
      } else {
        return types.handling.unhandled();
      }
    };

    return MemoryCacheStore;

  })(Store);

  OnPageCacheStore = (function(superClass) {
    extend(OnPageCacheStore, superClass);

    function OnPageCacheStore() {
      OnPageCacheStore.__super__.constructor.call(this);
    }

    OnPageCacheStore.prototype._dom = function() {};

    OnPageCacheStore.prototype.handle = function(request) {
      var cacheDom, signature;
      signature = request.signature();
      if (signature != null) {
        cacheDom = this._dom().find("> #" + signature);
        if (cacheDom.length > 0) {
          if (types.operation.fetch.match(request.type)) {
            request.set(types.result.success(cacheDom.text()));
            return types.handling.handled();
          } else {
            cacheDom.remove();
            return types.handling.unhandled();
          }
        } else {
          return types.handling.unhandled();
        }
      } else {
        return types.handling.unhandled();
      }
    };

    return OnPageCacheStore;

  })(Store);

  module.exports = {
    Request: Request,
    Store: Store,
    OneOfStore: OneOfStore,
    MemoryCacheStore: MemoryCacheStore,
    OnPageCacheStore: OnPageCacheStore
  };

}).call(this);
