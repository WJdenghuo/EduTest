// Generated by CoffeeScript 1.12.2
(function() {
  var capitalize, defcase, extendNew, isArray, isFunction, isPlainObject, match, otherwise, ref, unapply,
    slice = [].slice;

  ref = require('../util/util'), extendNew = ref.extendNew, capitalize = ref.capitalize, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction, isArray = ref.isArray;

  otherwise = function(value) {
    return {
      type: 'otherwise',
      value: value,
      "case": otherwise
    };
  };

  otherwise.type = 'otherwise';

  defcase = function() {
    var _, caseProps, child, fn, inTypes, iterProps, j, k, len, namespace, obj, process, ref1, results, set, setProps, type, types, v;
    namespace = arguments[0], inTypes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    set = {};
    setProps = {};
    if (isPlainObject(namespace)) {
      obj = namespace;
      for (k in obj) {
        v = obj[k];
        namespace = k;
        setProps = v;
      }
    }
    types = {};
    process = function(params) {
      var j, len, results1, type;
      results1 = [];
      for (j = 0, len = params.length; j < len; j++) {
        type = params[j];
        if (isPlainObject(type)) {
          results1.push((function() {
            var results2;
            results2 = [];
            for (k in type) {
              v = type[k];
              if (isArray(v)) {
                types[k] = {
                  children: v
                };
              } else {
                types[k] = v;
              }
              if (types[k].children != null) {
                results2.push(process(types[k].children));
              } else {
                results2.push(void 0);
              }
            }
            return results2;
          })());
        } else {
          results1.push(types[type] = {});
        }
      }
      return results1;
    };
    process(inTypes);
    for (_ in types) {
      iterProps = types[_];
      if (!(iterProps.children != null)) {
        continue;
      }
      results = [];
      ref1 = iterProps.children;
      for (j = 0, len = ref1.length; j < len; j++) {
        child = ref1[j];
        if (isPlainObject(child)) {
          for (k in child) {
            results.push(k);
          }
        } else {
          results.push(child);
        }
      }
      iterProps.children = results;
    }
    fn = function(type, caseProps) {
      var add, defaultProps, fType, fn1, instance, kase, prop, props, val;
      defaultProps = {
        arity: 1,
        map: function(f) {
          return kase(f(this.value));
        },
        toString: function() {
          return this.type + ": " + this.value;
        },
        unapply: function(x, additional) {
          if (isFunction(x)) {
            if (this.arity === 1) {
              return x.apply(null, [this.value].concat(slice.call(additional)));
            } else if (this.arity === 2) {
              return x.apply(null, [this.value, this.value2].concat(slice.call(additional)));
            } else if (this.arity === 3) {
              return x.apply(null, [this.value, this.value2, this.value3].concat(slice.call(additional)));
            }
          } else {
            return x;
          }
        }
      };
      props = extendNew(defaultProps, setProps, caseProps);
      instance = {
        type: type
      };
      fn1 = function(fType) {
        instance[fType + 'OrElse'] = function(x) {
          if (type === fType) {
            return this.value;
          } else {
            return x;
          }
        };
        instance['get' + capitalize(fType)] = function() {
          if (type === fType) {
            return this.value;
          } else {
            return this;
          }
        };
        return instance['map' + capitalize(fType)] = function(f) {
          if (type === fType) {
            return kase(f(this.value));
          } else {
            return this;
          }
        };
      };
      for (fType in types) {
        fn1(fType);
      }
      for (prop in props) {
        val = props[prop];
        instance[prop] = val;
      }
      kase = function(x, y, z) {
        var newInstance;
        newInstance = Object.create(instance);
        newInstance.value = x;
        if (props.arity >= 2) {
          newInstance.value2 = y;
        }
        if (props.arity >= 3) {
          newInstance.value3 = z;
        }
        return newInstance;
      };
      instance["case"] = kase;
      kase.isCase = true;
      kase.type = type;
      kase.set = set;
      kase.namespace = namespace;
      kase.match = function(x, f_) {
        var matches, xtype;
        xtype = x != null ? x.type : void 0;
        matches = (xtype === type) || (kase._allChildren[xtype] === true);
        if (isFunction(f_)) {
          if (matches) {
            return unapply(x, f_, []);
          }
        } else {
          return matches;
        }
      };
      kase._allChildren = {};
      add = function(type) {
        var children, l, len1, results1;
        if ((children = types[type].children) != null) {
          results1 = [];
          for (l = 0, len1 = children.length; l < len1; l++) {
            child = children[l];
            add(child);
            results1.push(kase._allChildren[child] = true);
          }
          return results1;
        }
      };
      add(type);
      return set[type] = kase;
    };
    for (type in types) {
      caseProps = types[type];
      fn(type, caseProps);
    }
    return set;
  };

  unapply = function(target, handler, additional, unapply) {
    if (unapply == null) {
      unapply = true;
    }
    if (isFunction(handler)) {
      if (isFunction(target != null ? target.unapply : void 0) && unapply === true) {
        return target.unapply(handler, additional);
      } else {
        return handler.apply(null, [target].concat(slice.call(additional)));
      }
    } else {
      return handler;
    }
  };

  match = function() {
    var args, child, first, hasOtherwise, i, kase, namespace, ref1, ref2, ref3, ref4, seen, set, x;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    first = args[0];
    set = (ref1 = (ref2 = first != null ? first["case"] : void 0) != null ? ref2 : first) != null ? ref1.set : void 0;
    namespace = (ref3 = (ref4 = first != null ? first["case"] : void 0) != null ? ref4 : first) != null ? ref3.namespace : void 0;
    seen = {};
    hasOtherwise = false;
    i = 0;
    while (i < args.length) {
      x = args[i];
      kase = x["case"] != null ? x["case"] : x;
      if (kase.type === 'otherwise') {
        hasOtherwise = true;
        break;
      } else {
        if (kase.namespace !== namespace) {
          throw new Error("found a case of some other set!");
        }
        seen[kase.type] = true;
        if (kase._allChildren != null) {
          for (child in kase._allChildren) {
            seen[child] = true;
          }
        }
      }
      i += x["case"] != null ? 1 : 2;
    }
    if (hasOtherwise === false) {
      for (kase in set) {
        if (seen[kase] !== true) {
          throw new Error('not all cases covered!');
        }
      }
    }
    return function() {
      var additional, handler, ref5, ref6, target, targetName;
      target = arguments[0], additional = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      i = 0;
      while (i < args.length) {
        x = args[i];
        if (x["case"] != null) {
          kase = x["case"];
          handler = x.value;
          i += 1;
        } else {
          kase = args[i];
          handler = args[i + 1];
          i += 2;
        }
        if (kase.type === 'otherwise') {
          return unapply(target, handler, additional, false);
        }
        if (((ref5 = (ref6 = target != null ? target["case"] : void 0) != null ? ref6 : target) != null ? ref5.namespace : void 0) === namespace) {
          targetName = target != null ? target.type : void 0;
          if ((kase.type === targetName) || (kase._allChildren[targetName] === true)) {
            return unapply(target, handler, additional);
          }
        }
      }
      return null;
    };
  };

  module.exports = {
    defcase: defcase,
    match: match,
    otherwise: otherwise
  };

}).call(this);
