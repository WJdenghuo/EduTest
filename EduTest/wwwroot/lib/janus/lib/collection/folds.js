// Generated by CoffeeScript 1.12.2
(function() {
  var Varying, foldBase, folds;

  Varying = require('../core/varying').Varying;

  foldBase = function(update) {
    return function(collection) {
      var result, watched;
      result = new Varying(null);
      watched = 0;
      collection.watchLength().react(function(length) {
        var fn, i, idx, ref, ref1;
        fn = function(idx) {
          return collection.watchAt(idx).react(function(value) {
            return result.set(update(value, idx, collection));
          });
        };
        for (idx = i = ref = watched, ref1 = length; ref <= ref1 ? i < ref1 : i > ref1; idx = ref <= ref1 ? ++i : --i) {
          fn(idx);
        }
        return watched = length;
      });
      return result;
    };
  };

  folds = {
    any: foldBase(function(value, _, collection) {
      var existTrue, i, item, len, ref;
      if (value !== true) {
        existTrue = false;
        ref = collection.list;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (item === true) {
            existTrue = true;
            break;
          }
        }
        return existTrue;
      } else {
        return true;
      }
    }),
    find: foldBase(function(value, idx, collection) {
      var elem, i, len;
      if (value === true) {
        return collection.list[idx];
      } else {
        for (i = 0, len = collection.length; i < len; i++) {
          elem = collection[i];
          if (f(elem) === true) {
            return elem;
          }
        }
        return null;
      }
    }),
    min: function(collection) {
      var last, update;
      last = null;
      update = function(value, idx, collection) {
        var largest, x;
        return last = last === null ? value : value <= last ? value : (largest = null, [
          (function() {
            var i, len, ref, results;
            ref = collection.list;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              x = ref[i];
              results.push(largest = largest != null ? Math.min(largest, x) : x);
            }
            return results;
          })()
        ], last = largest);
      };
      return foldBase(update)(collection);
    },
    max: function(collection) {
      var last, update;
      last = null;
      update = function(value, idx, collection) {
        var largest, x;
        return last = last === null ? value : value >= last ? value : (largest = null, [
          (function() {
            var i, len, ref, results;
            ref = collection.list;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              x = ref[i];
              results.push(largest = largest != null ? Math.max(largest, x) : x);
            }
            return results;
          })()
        ], last = largest);
      };
      return foldBase(update)(collection);
    },
    sum: function(collection) {
      var last, update, values;
      values = [];
      last = 0;
      update = function(value, idx, collection) {
        var diff, ref;
        diff = (value != null ? value : 0) - ((ref = values[idx]) != null ? ref : 0);
        values[idx] = value;
        return last += diff;
      };
      return foldBase(update)(collection);
    },
    join: function(collection, joiner) {
      return foldBase(function(_, _2, collection) {
        return collection.list.join(joiner);
      })(collection);
    },
    fold: function(collection, memo, f) {
      var intermediate, update;
      intermediate = [];
      intermediate[-1] = Varying.ly(memo);
      update = function(value, idx, collection) {
        var i, ref, ref1, start;
        start = Math.min(intermediate.length, idx);
        for (idx = i = ref = start, ref1 = collection.list.length; ref <= ref1 ? i < ref1 : i > ref1; idx = ref <= ref1 ? ++i : --i) {
          intermediate[idx] = intermediate[idx - 1].map(function(last) {
            return f(last, value);
          });
        }
        return intermediate[intermediate.length - 1];
      };
      return foldBase(update)(collection);
    },
    scanl: function(collection, memo, f) {
      var intermediate;
      intermediate = new (require('./list').List)();
      intermediate.add(Varying.ly(memo));
      collection.watchLength().react(function(length) {
        var i, idx, intermediateLength, j, ref, ref1, ref2, ref3, results, results1;
        intermediateLength = intermediate.list.length - 1;
        if (length > intermediateLength) {
          results = [];
          for (idx = i = ref = intermediateLength, ref1 = length; ref <= ref1 ? i < ref1 : i > ref1; idx = ref <= ref1 ? ++i : --i) {
            results.push((function(idx) {
              return intermediate.add(Varying.combine([intermediate.watchAt(idx), collection.watchAt(idx)], f));
            })(idx));
          }
          return results;
        } else if (length > intermediateLength) {
          results1 = [];
          for (idx = j = ref2 = length, ref3 = intermediateLength; ref2 <= ref3 ? j < ref3 : j > ref3; idx = ref2 <= ref3 ? ++j : --j) {
            results1.push(intermediate.removeAt(intermediateLength));
          }
          return results1;
        }
      });
      return intermediate;
    },
    foldl: function(collection, memo, f) {
      return folds.scanl(collection, memo, f).watchAt(-1);
    }
  };

  module.exports = folds;

}).call(this);
