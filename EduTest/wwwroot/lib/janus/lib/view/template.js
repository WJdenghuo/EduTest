// Generated by CoffeeScript 1.12.2
(function() {
  var build, defaultMutators, find, rechain, selectorToWalks, template, walk, wrap,
    slice = [].slice;

  defaultMutators = require('./mutators');

  wrap = function(dom) {
    var wrapper;
    dom.prepend('<div/>');
    wrapper = dom.children(':first-child');
    wrapper.remove();
    wrapper.append(dom);
    return wrapper;
  };

  selectorToWalks = function(dom, selector) {
    var rawDom;
    rawDom = dom.get(0);
    return dom.find(selector).map(function(_, target) {
      var i, idx, parent, ref, walk;
      walk = [];
      while ((parent = target.parentNode) !== rawDom) {
        for (idx = i = 0, ref = parent.childNodes.length; 0 <= ref ? i <= ref : i >= ref; idx = 0 <= ref ? ++i : --i) {
          if (!(parent.childNodes[idx] === target)) {
            continue;
          }
          walk.unshift(idx);
          break;
        }
        target = parent;
      }
      return [walk];
    });
  };

  walk = function(dom, walks) {
    var rawDom;
    rawDom = dom.get(0);
    return walks.map(function(_, walk) {
      var i, idx, len, ptr;
      ptr = rawDom;
      for (i = 0, len = walk.length; i < len; i++) {
        idx = walk[i];
        ptr = ptr.childNodes[idx];
      }
      return ptr;
    });
  };

  rechain = function(chains, mutators, selector) {
    var fn, head, i, k, result, tail, v;
    result = function(fragment) {
      var walks;
      walks = selectorToWalks(wrap(fragment), selector);
      return function(dom, point) {
        var chain, i, len, results, target;
        target = walk(dom, walks);
        results = [];
        for (i = 0, len = chains.length; i < len; i++) {
          chain = chains[i];
          results.push(chain(target, point));
        }
        return results;
      };
    };
    head = 2 <= chains.length ? slice.call(chains, 0, i = chains.length - 1) : (i = 0, []), tail = chains[i++];
    if (tail != null) {
      fn = function(v) {
        return result[k] = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return rechain(head.concat([v.apply(null, args)]), mutators, selector);
        };
      };
      for (k in tail) {
        v = tail[k];
        fn(v);
      }
    }
    for (k in mutators) {
      v = mutators[k];
      if (result[k] == null) {
        (function(v) {
          return result[k] = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return rechain(chains.concat([v.apply(null, args)]), mutators, selector);
          };
        })(v);
      }
    }
    return result;
  };

  build = function(mutators) {
    return function(selector) {
      return rechain([], mutators, selector);
    };
  };

  find = build(defaultMutators);

  find.build = build;

  template = function() {
    var xs;
    xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(fragment) {
      var prebound, x;
      prebound = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = xs.length; i < len; i++) {
          x = xs[i];
          results.push(x(fragment));
        }
        return results;
      })();
      return function(dom, point) {
        var f;
        return Array.prototype.concat.apply([], (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = prebound.length; i < len; i++) {
            f = prebound[i];
            results.push(f(dom, point));
          }
          return results;
        })());
      };
    };
  };

  module.exports = {
    find: find,
    template: template
  };

}).call(this);
